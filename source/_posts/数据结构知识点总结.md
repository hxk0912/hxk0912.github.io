---
title: 数据结构知识点总结
date: 2019-12-11 20:37:38
categories: 数据结构
tags:
---

## 第一章 绪论

### 一些概念

*数据结构就是研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。*

01. 数据：所有能被输入到计算机中，且能被计算机处理的符号的集合。是计算机操作的对象的总称。
02. 数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的基本单位
03. 数据项：数据的不可分割的最小单位。一个数据元素可由若干个数据项组成。
04. 数据类型：在一种程序设计语言中，变量所具有的数据种类。整型、浮点型、字符型等等

### 四类基本数据结构

01. 集合结构。该结构的数据元素间的关系是“属于同一个集合”。
02. 线性结构。该结构的数据元素之间存在着一对一的关系。
03. 树型结构。该结构的数据元素之间存在着一对多的关系。
04. 图形结构。该结构的数据元素之间存在着多对多的关系，也称网状结构。

### 逻辑结构与物理结构的基本概念

逻辑结构：数据之间的相互关系。（可以分为线性结构和非线性结构）

物理结构：数据在计算机中的表示。物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、哈希结构）等。

数据结构的基本操作的设置的最重要的准则是, **实现应用程序与存储结构的独立**。

### 算法及其特性、算法设计的要求、算法的时间复杂度和空间复杂度

算法五个特性： 有穷性、确定性、可行性、输入、输出。

算法设计要求：正确性、可读性、健壮性、高效率与低存储量需求。(好的算法)

时间复杂度：算法的执行时间与原操作执行次数之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)、O(n<sup>3</sup>)。幂次时间复杂度有小到大O(2<sup>n</sup>)、O(n!)、O(n<sup>n</sup>)

空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间。

## 第二章 线性表

### 线性表的概念

线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储），但是把最后一个数据元素的尾指针指向了首位结点）。

### 顺序存储和链式存储的原理及不同特点

#### 顺序存储

线性表的顺序存储结构：把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。是一种随机存取的存储结构。顺序存储指内存地址是一块的。

特点：

* 便于线性表的构造和任意元素的访问
* 插入：插入新结点，之后结点后移。平均时间复杂度: O(n)
* 删除：删除节点，之后结点前移。平均时间复杂度: O(n)

#### 链式存储

线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。不需要事先估计存储空间大小。

特点：

* 查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，链表不是随机存取结构。
* 插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。
* 删除：首先找到ai-1的存储位置p。然后令p–>next指向ai的直接后继结点，即把ai从链上摘下。最后释放结点ai的空间.r=p->next; p->next=r->next; delete r。

#### 顺序表和链表的优缺点比较：

| -   | 顺序表                                                                          | 链表                                                              |
|-----|--------------------------------------------------------------------------------|-------------------------------------------------------------------|
| 优点 | 1. 存储空间连续，便于随机访问；2. 查找算法的时间复杂性为O(1)， 即常量级。                   | 1. 插入与删除运算的效率高，时间复杂性为O(1)；2. 长度不固定，可以随意增删改    |
| 缺点 | 1. 需预先分配相应的存储空间；2. 插入与删除运算的效率很低，时间复杂性为O(n)；3. 不可以增长长度。 | 1. 不可随机存取；2. 占用额外的空间以存储指针；3. 查找速度慢，时间复杂性为O(n)。 |

### 循环链表和双链表的概念

循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。

在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—>next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。

双向链表: 在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：

`p—>prior—>next=p=p—>next—>prior` 

特点：

* 插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。
* 在有序双向链表中定位删除一个元素的平均时间复杂度为O(n)
* 可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表

## 第三章 栈和队列

### 栈和队列的概念、特点

栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增

队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。

循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”（通常两种解决方案：要么添加标志位，要么多使用一个数据空间强行将头尾分开）。循环队列不能用顺序结构实现，一般通过链队列实现。

### 两者异同

| 相同点                                                                                                                          | 不同点                                                   |
|--------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|
| 插入操作都是限定在表尾进行。（栈的栈顶，队列的队尾），都可以通过顺序存储结构和链式存储结构实现。（4）插入和删除的时间复杂度都是O(1)，在空间复杂度上两者也一样。 | 1）删除元素的位置不同，栈的操作在表尾进行，队列的删除操作在表头进行。 |

### 与线性表的关系

栈和队列都是线性表，都是限制了插入删除点的线性表（或者说是控制了访问点的线性表）。

### 栈和队列的应用

#### 栈的应用

01. 进制转换
02. 括号匹配的检验
03. 行编辑程序
04. 迷宫求解：若当前位置“可通”，则纳入路径，继续前进;若当前位置“不可通”，则后退，换方向继续探索;若四周“均无通路”，则将当前位置从路径中删除出去。
05. 表达式求解：前缀、中缀、后缀。
06. 实现递归：多个函数嵌套调用的规则是：后调用先返回。

#### 队列的应用

01. 迷宫求解：广度遍历。
02. 离散事件模拟：顾客来去。

## 第六章 树与二叉树

### 基本术语

01. 树结点：包含一个数据元素及若干指向子树的分支；
02. 孩子结点：结点的子树称为该结点的孩子；
03. 双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲；
04. 兄弟结点：同一双亲的孩子结点；
05. 堂兄结点：同一层上结点；
06. 结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推；
07. 树的高（深）度：树中最大的结点层
08. 结点的度：结点子树的个数
09. 树的度： 树中最大的结点度。
10. 叶子结点：也叫终端结点，是度为0的结点；
11. 分枝结点：度不为0的结点（非终端结点）；
12. 森林：互不相交的树集合；
13. 有序树：子树有序的树，如：家族树；
14. 无序树：不考虑子树的顺序；

### 二叉树概念及其各种性质

#### 概念

二叉树是n(n>=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。

#### 特点

01. 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。
02. 左子树和右子树是有顺序的，次序不能任意颠倒。
03. 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

#### 性质

01. 在二叉树的第i层上最多有2<sup>i-1</sup> 个节点 。（i>=1）
02. 二叉树中如果深度为k,那么最多有2<sup>k</sup>-1个节点。(k>=1）
03. n<sub>0</sub>=n<sub>2</sub>+1 n<sub>0</sub>表示度数为0的节点数(叶子结点)，n<sub>2</sub>表示度数为2的节点数（左右子树都有的结点）。
04. 在完全二叉树中，具有n个节点的完全二叉树的深度为[log<sub>2</sub>n]+1，其中[log<sub>2</sub>n]是向下取整。
05. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：

* 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点; 
* 若 2i>n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；
* 若 2i+1>n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。

### 满二叉树

满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

#### 性质

满二叉树的特点有：

01. 叶子只能出现在最下一层。出现在其它层就不可能达成平衡。
02. 非叶子结点的度一定是2。
03. 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

![alt](http://m.qpic.cn/psb?/V11NehB63qJi50/VLB3IGAaU7.pTGkFam39YuICaQQw6VbjmTsM8wFxOGk!/b/dLYAAAAAAAAA&bo=iAHiAAAAAAARF0s!&rf=viewer_4)

### 完全二叉树

完全二叉树：对一颗具有n个结点的二叉树按层编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

#### 性质

01. 叶子结点只能出现在最下层和次下层。
02. 最下层的叶子结点集中在树的左部。
03. 倒数第二层若存在叶子结点，一定在右部连续位置。
04. 如果结点度为1，则该结点只有左孩子，即没有右子树。
05. 同样结点数目的二叉树，完全二叉树深度最小。**注**：满二叉树一定是完全二叉树，但反过来不一定成立。

![alt](http://m.qpic.cn/psb?/V11NehB63qJi50/tom8MlBpHRCpBSbWAUXm3pdUboBSgWKgSDRE5UPhIWQ!/b/dFIBAAAAAAAA&bo=lAH4AAAAAAARB10!&rf=viewer_4)

### 遍历二叉树

遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。

* 先序遍历DLR：根节点->左子树->右子树
* 中序遍历LDR：左子树->根节点->右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序
* 后续遍历LRD：左子树->右子树->根节点。需要栈的支持。
* 层次遍历：用一维数组存储二叉树时, 总是以层次遍历的顺序存储结点。层次遍历应该借助队列。

### 哈夫曼编码树

#### 一些概念

01. 路径：从一个祖先结点到子孙结点之间的分支构成这两个结点间的路径；
02. 路径长度：路径上的分支数目称为路径长度；
03. 树的路径长度：从根到每个结点的路径长度之和。
04. 结点的权：根据应用的需要可以给树的结点赋权值；
05. 结点的带权路径长度：从根到该结点的路径长度与该结点权的乘积；
06. 树的带权路径长度=树中所有叶子结点的带权路径之和；通常记作 WPL=∑wi×li
07. 哈夫曼树：假设有n个权值(w1, w2, … , wn)，构造有n个叶子结点的二叉树，每个叶子结点有一个 wi作为它的权值。则带权路径长度最小的二叉树称为哈夫曼树。最优二叉树。

#### 性质

* 给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树。
* 假设哈夫曼树是二叉的话，则度为0的结点个数为N，度为2的结点个数为N-1，则结点总数为2N-1。哈夫曼树的结点个数必为奇数。
* 哈夫曼树不一定是完全二叉树，但一定是最优二叉树。
* 若度为m的哈夫曼树中, 其叶结点个数为n, 则非叶结点的个数为[(n-1)/(m-1)]。边的数目等于度。

[构造哈夫曼树](https://blog.csdn.net/qingdujun/article/details/54093419#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0)

[哈夫曼编码](https://hxk0912.github.io/2019/10/22/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/)

### 堆

[堆的理解](https://hxk0912.github.io/2019/10/29/%E5%A0%86/)

## 第九章 查找

### 顺序查找和二分查找的原理与特点

顺序查找：应用于顺序表或线性链表表示的表，表内元素之间无序。查找过程：从表的一端开始逐个进行记录的关键字和给定值的比较。

二分查找：应用于有序的表，所以若表的元素的插入与删除很频繁，维持表有序的工作量极大。查找方式：从中间开始，类似于二分法的方式查找。

### 哈希表

[哈希表](https://hxk0912.github.io/2019/10/17/%E5%93%88%E5%B8%8C%E8%A1%A8/)

### 二叉查找树（BST）

[二叉查找树](https://hxk0912.github.io/2019/12/12/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/)

### 查找方法之间比较

## 第十章 内部排序

[内部排序](https://hxk0912.github.io/2019/10/29/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F/)

## 第十一章 外部排序

### 磁盘结构及相关术语

### 设计基于磁盘的应用程序的最高原则

### 外排序的基本原理

### 好的外排序方法的基本原则

