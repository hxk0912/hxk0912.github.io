---
title: 指令系统
date: 2020-03-10 08:33:19
categories: 微机原理与接口技术
tags:
---

## 基本概念

- 指令
  - 计算机要执行的各种操作命令
  - 一条指令对应着一种基本操作
- 指令系统

  - 对特定的计算机而言，其所有指令的集合
  - 每种计算机都有其特定的指令系统

- 复杂指令集计算机 CISC

Complex instruction set computer
指每个操作都有对应的指令，8086/8088 系列就是复杂指令集。

- 精简指令集计算机 RISC

Reduced instruction set computer
只有最常用的操作指令，其他不常用操作指令用这些常用指令来表示。

## 指令的基本格式

- 操作码(operation code)
  - 规定指令要执行的操作, 不可缺少。
- 操作数(operand)
  - 指出执行指令所需要操作数的来源：
    - 操作数本身
    - 操作数地址 或 操作数地址的计算方法
- 多数情况可以有 1 或多个操作数
  - 单操作数
  - 双操作数：源操作数、目的操作数
  - 隐含操作数

## 寻址

- 寻址
  - 寻找操作数的过程
- 操作数在哪些地方呢？
  - 直接在指令中
  - 在 CPU 的某个寄存器中
  - 在内存中
  - 在 I/O 端口或外部设备中
- 寻址方式
  - 产生地址的各种方法
  - 对于双操作数指令而言, 源和目的操作数有可能不同。

### 寻址方式

#### 立即寻址

指令所需操作数就在指令中, 紧跟在操作码之后, 与操作码一起放在代码段。

#### 寄存器寻址

操作数存放在 CPU 的内部寄存器中, 在指令中直接给出寄存器名。

#### 存储器寻址方式

操作数在主存储器中, 指令需要给出操作数的地址信息。

#### 直接寻址

操作数在存储单元中, 指令中操作数字段给出的是操作数的 16 位偏移地址 EA。
默认的段基地址在 DS 段寄存器, 可使用段超越前缀改变。
用中括号包含有效地址, 表达存储单元的内容。

`MOV AX, [2000H] ；AX←DS:[2000H]`
`MOV AX, ES: [2000H] ；AX←ES:[2000H]`

在汇编语言中, 经常用符号地址来代替数值地址。
举例 `MOV AX, STRING`
其中 STRING 为存储单元的符号地址
如果 STRING 代表的数值地址是 2000H, 则该指令等同于`MOV AX, [2000H]`

#### 寄存器间接寻址

操作数在主存储器中, 操作数的有效地址 EA 由 BX、BP、SI、DI 中的一个指出。

- 对于 BX、SI、DI, 默认的段基地址在 DS 段寄存器, 可使用段超越前缀改变。
- 对于 BP, 默认的段基地址在 SS 段寄存器, 可使用段超越前缀改变。

`MOV AX, [BX] ；AX←DS:[BX]`

#### 寄存器相对寻址

操作数在主存储器中, 操作数的有效地址：
EA = BX/BP/SI/DI + 8/16 位偏移量

- 对于 BX、SI、DI, 默认的段基地址在 DS 段寄存器, 可使用段超越前缀改变。
- 对于 BP, 默认的段基地址在 SS 段寄存器, 可使用段超越前缀改变。

`MOV AX, [SI+06H] ；AX←DS:[SI+06H]`

寄存器相对寻址可以表示成几种不同的形式。

`MOV AX, BUFFER[BP]`\
`MOV AX,[BP]BUFFER`\
`MOV AX,[BP+BUFFER]`\
`MOV AX,[BUFFER+BP]`

#### 基址加变址

操作数在主存储器中, 操作数的有效地址：
EA = BX/BP + SI/DI

- 对于 BX, 默认的段基地址在 DS 段寄存器, 可使用段超越前缀改变。
- 对于 BP, 默认的段基地址在 SS 段寄存器, 可使用段超越前缀改变

`MOV AX, [BX+SI] ；AX←DS:[BX+SI]`

#### 相对基址加变址

操作数在主存储器中, 操作数的有效地址：
EA = BX/BP + SI/DI + 8/16 位偏移量

- 对于 BX, 默认的段基地址在 DS 段寄存器, 可使用段超越前缀改变。
- 对于 BP, 默认的段基地址在 SS 段寄存器, 可使用段超越前缀改变。

`MOV AX, 10H[BP][SI] ; AX←SS:[BP+SI+10H]`

#### 隐含寻址

指令的部分或全部操作数被隐含, 没有直接出现在指令助记符中。
操作对象一般是固定的。

## 指令

除标志传送指令外, 其余指令均不影响标志位。

### 数据传输指令

#### 基本传输指令 MOV

`MOV dst，src`

将源操作数的内容复制到目的操作数, 源操作数内容不变。
目的操作数 dst 写前, 源操作数 src 写后, 用逗号隔开。

特点：

1. 可完成 8、16 位数的传送。
2. 可使用各种寻址方式。
3. 不影响标志位。

注意事项

1. 存储单元之间不能直接传送。
2. 立即数不能作为目的操作数。
3. **段寄存器之间不能直接传送。**
4. **不能将立即数直接传送给段寄存器。**
5. CS 和 IP 不能作为目的操作数。
6. **源操作数和目的操作数的类型必须一致。**
7. 传送字单元时, 遵循“高字节在高地址, 低字节在低地址”原则。
8. 除串操作指令外, 不允许两个操作数都是存储器操作数。

#### 交换指令 XCHG

`XCHG dst，src`

将源操作数 src 的内容与目的操作数 dst 的内容互换。

注意：

1. 操作数可以是 8、16 位数。
2. 源和目的操作数可以是寄存器或存储器，但不能同时为存储器操作数。
3. 段寄存器、立即数不能参加交换。
4. 不影响标志位。

#### 进栈指令 PUSH

`PUSH src`

说明

1. src 可以是通用寄存器、段寄存器和存储单元。
2. **8086/8088 的堆栈操作都是以字为单位。**
3. 遵循“高字节在高地址, 低字节在低地址”。

#### 出栈指令 POP

`POP dst`

说明

1. dst 可为通用寄存器、段寄存器和存储单元。
2. CS 可入栈, 但不能从堆栈弹出数据到 CS。

#### 输入输出指令 IN OUT

端口:外设与 CPU 的接口\
端口地址:端口的编号, 以区分不同的端口\
端口寻址

- 直接端口寻址:由指令中的 8 位数决定, 范围 0~255
- 间接端口寻址:由 DX 决定, 范围 0~65535

`IN ac，port`

从端口输入字节或字到累加器

- 如果累加器为 AL, 则从端口输入 1 字节
- 如果累加器为 AX, 则 AL←port , AH ←port+1

`OUT port，ac`

将累加器的内容输出到端口

- 如果累加器为 AL, 则输出 AL 内容 →port
- 如果累加器为 AX, 则 AL → port, AH→ port+1

#### 地址传送指令 LEA

`LEA reg，src`

功能:将存储器操作数 src 的有效地址送至指定的 16 位通用寄存器

说明:reg:16 位通用寄存器 src:存储器操作数

### 算数运算指令

- 执行二进制运算和十进制运算。
- 操作数有 8、16 位数, 也分为无符号数和带符号数。
- 大部分指令会对标志位有影响, 不过不同指令的影响各不相同。

#### 加减法指令

执行字或字节的加法、减法运算。

除 INC 和 DEC 不影响 CF 标志外, 其他按定义影响全部状态标志位

- ADD dst←dst+src
- SUB dst←dst-src
- ADC dst←dst+src+CF
- SBB dst←dst-src-CF
- INC dst←dst+1 不影响 CF
- DEC dst←dst-1 不影响 CF
- NEG dst←0-dst
- CMP dst-src 将目的操作数减去源操作数, 但结果不回送目的操作数。影响状态标志

### 逻辑运算和移位指令

按位进行操作, 位与位之间无进位或借位。

当需要对字节或字的某个二进制位进行操作时, 可考虑使用。

执行与、或、非等逻辑运算。

NOT 指令对标志位无影响, 其余指令执行后,总是使 CF=OF=0,根据运算结果设置 SF、ZF、PF。

#### 逻辑运算指令

- AND dst ← dst & src
- TEST dst & src
- OR dst ← dst | src
- XOR dst ← dst ⊕ src
- NOT dst ← ~ dst

#### 移位指令

- 将操作数移动一位或多位, 分别具有左移或右移操作。
- 移位操作分成逻辑移位和算术移位。
- 移位指令的操作数可以是8/16位的通用寄存器或存储器。
- 移位次数要么是1, 要么是CL。
- 都会影响标志位, 主要是学习CF。

- SHL\SAL  dst，1或CL 逻辑左移，最低位补0，最高位→CF
- SHR  dst，1或CL 逻辑右移，最高位补0, 最低位→CF
- SAR  dst，1或CL 算数右移，最高位不变, 最低位→CF

- ROL  dst，1或CL 不带进位的循环左移
- ROR  dst，1或CL 不带进位的循环右移
- RCL  dst，1或CL 带进位的循环左移 最高位→CF CF→最低位
- RCR  dst，1或CL 带进位的循环右移 最低位→CF CF→最高位

### 控制转移指令

改变指令的顺序执行, 用于实现分支、循环等程序结构。

除中断指令外, 其他指令均不影响标志位。

8086/8088中, 指令的执行顺序是由CS:IP决定的。

一般情况下, 指令是顺序执行的。如要改变指令的顺序执行, 就需要改变CS或IP。

控制转移类指令通过改变IP或CS值, 实现程序执行顺序的改变。

当程序发生转移时, 存放在指令队列寄存器中的指令被清除, BIU将根据新的CS:IP值从存储器中取出新的指令,并直接送EU执行

控制转移指令需要确定转移的目标地址。

目标地址可以在段内, 也可以跨段(段间)。

段内转移只修改IP, 而段间转移要修改CS和IP。

#### 段内直接寻址

段内转移只修改IP, CS内容不变。

指令码中包含一个8/16位偏移量disp。

转移的目标地址=IP+disp

段内短转移：disp为8位, -128～+127

段内近转移：disp为16位, -32768～+32767

注意
- IP的当前值是指从存储器中取出转移指令后的IP值, 实际上是下一条指令的地址。
- disp为带符号数, 用补码表示。
又称相对寻址。

#### 其他寻址

段内间接寻址
- 转移的目标地址在16位寄存器或存储单元中。

段间直接寻址
- 段间转移, 需要修改CS和IP。
- 转移的目标地址直接由指令码形式地址提供。

段间间接寻址
- 转移的目标地址由4个连续字节存储单元(32位)提供。
- 前2个字节单元送入IP, 后2个字节单元送入CS

#### 无条件转移JMP

`JMP  label`

无条件地转移到指令规定的目标地址label。

#### 条件转移指令Jcc

`Jcc  label`

功能: 根据指定条件是否成立来确定程序是否转移。

cc表示某种条件。

若条件满足, 发生转移(IP←IP＋8位位移量)。

否则, 顺序执行。

label是一个标号, 表示一个8位位移量。

label只支持段内直接短转移寻址方式, 即相对短转移。



    JE/JZ               等于/为0 时跳转(ZF=1)这里计算机判断

    JNE/JNZ             不为0时转移(ZF=0时判断)

    有符号的：

    JG/JNLE            大于/不小于等于

    JNG/JLE            不大于/小于等于

    JL/JNGE            小于/不大于等于

    JNL/JGE            不小于/大于等于

    无符号的：

    JB/JNAE           低于/不高于等于

    JNB/JAE            不低于/高于等于

    JA/JNBE            高于/不低于等于

    JNA/JBE           不高于/低于等于

    JS     当SF为1时跳转

    JNS    当SF为0时转移

    JO    当OF为1时跳转

    JNO   当OF为0时转移

    JP    当PF为1时跳转

    JNP   当PF为0时转移  

### 循环控制指令

`LOOP label`

1. CX←CX-1	DEC操作，不影响标志位
2. 若CX≠0, 则转移; 否则, 顺序执行。

### 过程调用与返回指令

- 在程序设计中, 通常把大的程序分解为若干个小的功能模块。
- 每个功能模块对应一个过程, 又称子程序,与C语言中的函数类似。
- 主程序可以调用一个子程序, 子程序执行完毕后要返回主程序调用处继续往下执行。

#### 调用指令 CALL

`CALL  label`

功能：
1. 断点地址入栈, 即保存断点地址。
2. 转移。

断点地址的保存

段内调用只需要保存断点IP。

SS←SP-2\
SS:[SP]←当前IP

段间调用需要保存断点地址的CS:IP。

SP←SP-2, SS:[SP]←当前CS\
SP←SP-2, SS:[SP]←当前IP

转移, 类似JMP

段内调用只改变IP, 段间调用改变CS和IP。
目标地址的寻址与JMP类似。

#### 返回指令 RET

`RET  [ n ]`

功能：
- 从栈顶弹出由CALL压入的断点地址, 送入IP或CS:IP, 以返回断点处继续执行。
- 如果带参数n, 在弹出断点地址后, 还需执行 SP ←SP + n 。

#### 中断指令

中断(interrupt)是另外一种改变程序执行顺序的方法。

8088CPU支持256个中断, 每个中断用一个编号(中断向量号)区别。

##### 中断调用指令INT 

`INT n`

中断调用指令: 产生n号中断。

主程序使用, 其中n表示中断向量号。

##### 中断返回指令IRET

`IRET`

中断返回指令: 实现中断返回。

中断服务程序使用。
