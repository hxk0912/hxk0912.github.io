---
layout: 
title: makefile基础
date: 2020-01-29 16:39:56
categories: Linux
tags:
---

## 什么是Makefile

我们在进行实际开发的时候工程里面可能有几十上百个文件等待编译，为解决这个问题。用来描述哪些文件需要编译、哪些需要重新编译的文件就叫做Makefile。

## Makefile功能

1. 如果工程没有编译过，那么工程中的所有 .c文件都要被编译并且链接成可执行程序。
2. 如果工程中只有个别 C文件被修改了，那么只 编译这些被修改的 C文件即可。
3. 如果工程的头文件被修改了，那么我们需要编译所有引用这个头文件的 C文件，并且链接成可执行文件。

## Makefile语法

``` Makefile
main:main.o a.o b.o
    gcc -o main main.o a.o b.o
main.o:main.c
    gcc -c main.c
a.o:a.c
    gcc -c a.c
b.o:b.c
    gcc -c b.c

clean:
    rm *.o
    rm main
```

**命令列表中的每条命令必须以TAB键开始，不能使用空格！**

简单总结：
[目标]：[依赖]
    [命令]

### 执行过程

1. make命令会在当前目录下查找以 Makefile(makefile其实也可以 )命名的文件。
2. 当找到 Makefile文件以后就会按照 Makefile中定义的规则去编译生成最终的目标文件。
3. 当发现目标文件不存在，或者目标所依赖的文件比目标文件新 (也就是最后修改时间比目标文件晚 )的话就会执行后面的命令来更新目标。

## 伪目标

比如我们文件夹中有了一个名叫 clean的文件，那么每次都是最新的文件，就不会正常执行我们定义的命令了。

为了解决这种问题，Makefile使用”.PHONY”前缀来区分目标代号和目标文件，并且这种目标代号被称为”伪目标”。

也就是说如果不需要生成文件，就把目标定义为伪目标就好

```makefile

.PHONY:clean
clean: 
    rm -f *.o
```

## 默认规则

当找不到xxx. o文件时，会查找目录下的同名xxx.c文件进行编译。

比如我需要a.o而且我文件夹内有a.c，那么我就可以省略编译a.c编程a.o的代码。

``` makefile
#下面两行根据默认规则可以省略了
#a.o:a.c
#    gcc -c a.c
```

## Makefile变量

makefile中变量就类似于C语言中的宏定义

``` makefile
#   makefile 变量的使用
macro = main.o a.o b.o
main:$(macro)
    gcc -o main $(macro)
```

### 赋值符

* =  延时赋值，该变量只有在调用的时候，才会被赋值,变量赋值后会一直使用最新的变量值
* := 直接赋值，与延时赋值相反，使用直接赋值的话，变量的值定义时就已经确定了,变量赋值后只会使用最初定义的变量值
* ?= 若变量的值为空，则进行赋值，通常用于设置默认值。,变量赋值时如果前面有定义就使用前面的值，没有定义就用这个值
* += 追加赋值，可以往变量后面增加新的内容,就像字符串的拼接

### 改造默认规则
